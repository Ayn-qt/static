# =============================================================
# LAB 1A – CAESAR CIPHER
# =============================================================

def caesar_cipher(text, shift):
    result = ""
    for char in text:
        if char.isupper():
            result += chr((ord(char) - 65 + shift) % 26 + 65)
        elif char.islower():
            result += chr((ord(char) - 97 + shift) % 26 + 97)
        else:
            result += char
    return result
print("\n===== CAESAR CIPHER =====")
text = input("Enter text: ")
shift = int(input("Enter shift value: "))
mode = input("Encrypt or Decrypt? (e/d): ").lower()
if mode == "e":
    print("Encrypted:", caesar_cipher(text, shift))
else:
    print("Decrypted:", caesar_cipher(text, -shift))






# =============================================================
# LAB 1B – MONOALPHABETIC CIPHER
# (No imports in PDF)
# =============================================================

ALPH = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
KEY = "QWERTYUIOPASDFGHJKLZXCVBNM"

enc_map = {ALPH[i]: KEY[i] for i in range(26)}
dec_map = {KEY[i]: ALPH[i] for i in range(26)}

def mono_encrypt(msg):
    return ''.join(enc_map.get(c, c) for c in msg.upper())

def mono_decrypt(msg):
    return ''.join(dec_map.get(c, c) for c in msg.upper())

print("\n===== MONOALPHABETIC CIPHER =====")
text = input("Enter text: ")
mode = input("Encrypt or Decrypt? (e/d): ").lower()

if mode == "e":
    print("Encrypted:", mono_encrypt(text))
else:
    print("Decrypted:", mono_decrypt(text))






# =============================================================
# LAB 1C – VIGENERE CIPHER
# (No imports in PDF)
# =============================================================

ALPH = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
def vig_encrypt(text, key):
    text, key = text.upper(), key.upper()
    res = ""
    k = 0
    for c in text:
        if c.isalpha():
            shift = ALPH.index(key[k % len(key)])
            res += ALPH[(ALPH.index(c) + shift) % 26]
            k += 1
        else:
            res += c
    return res
def vig_decrypt(text, key):
    text, key = text.upper(), key.upper()
    res = ""
    k = 0
    for c in text:
        if c.isalpha():
            shift = ALPH.index(key[k % len(key)])
            res += ALPH[(ALPH.index(c) - shift) % 26]
            k += 1
        else:
            res += c
    return res
print("\n===== VIGENERE CIPHER =====")
txt = input("Enter text: ")
key = input("Enter key: ")
mode = input("Encrypt or Decrypt? (e/d): ").lower()
if mode == "e":
    print("Encrypted:", vig_encrypt(txt, key))
else:
    print("Decrypted:", vig_decrypt(txt, key))






# =============================================================
# LAB 1D – COLUMNAR TRANSPOSITION CIPHER
# (No imports in PDF)
# =============================================================

def col_encrypt(pt, key):
    pt = pt.replace(" ", "").upper()
    k = len(key)
    order = sorted(range(k), key=lambda i: key[i])
    cols = [""] * k
    for i, ch in enumerate(pt):
        cols[i % k] += ch
    return ''.join(cols[i] for i in order)
def col_decrypt(ct, key):
    k = len(key)
    order = sorted(range(k), key=lambda i: key[i])
    n = len(ct)
    lengths = [n // k] * k
    for i in range(n % k):
        lengths[i] += 1
    parts = {}
    idx = 0
    for i, ln in zip(order, lengths):
        parts[i] = ct[idx:idx + ln]
        idx += ln
    pt = ""
    for i in range(max(lengths)):
        for c in range(k):
            if i < len(parts[c]):
                pt += parts[c][i]
    return pt
print("\n===== COLUMNAR TRANSPOSITION =====")
msg = input("Enter message: ")
key = input("Enter key: ")
mode = input("Encrypt or Decrypt? (e/d): ")
if mode == "e":
    print("Encrypted:", col_encrypt(msg, key))
else:
    print("Decrypted:", col_decrypt(col_encrypt(msg, key), key))







# ===========================================================
# LAB 2 – DES
# =============================================================
!pip install pycryptodome
from Crypto.Cipher import DES
from Crypto.Util.Padding import pad, unpad
print("\n===== DES CIPHER =====")
key = b"abcdefgh"
plaintext = input("Enter message: ").encode()
cipher = DES.new(key, DES.MODE_ECB)
ct = cipher.encrypt(pad(plaintext, DES.block_size))
print("Encrypted:", ct)
decipher = DES.new(key, DES.MODE_ECB)
pt = unpad(decipher.decrypt(ct), DES.block_size)
print("Decrypted:", pt.decode())


# =============================================================
# LAB 2 – AES
# =============================================================

from Crypto.Cipher import AES
from Crypto.Random import get_random_bytes
from Crypto.Util.Padding import pad as aes_pad, unpad as aes_unpad
import base64
print("\n===== AES CIPHER =====")
key = get_random_bytes(16)
iv = get_random_bytes(16)
msg = input("Enter message: ").encode()
cipher = AES.new(key, AES.MODE_CBC, iv)
ct = cipher.encrypt(aes_pad(msg, AES.block_size))
print("Encrypted:", ct)
dec = AES.new(key, AES.MODE_CBC, iv)
pt = aes_unpad(dec.decrypt(ct), AES.block_size)
print("Decrypted:", pt.decode())






# =============================================================
# LAB3 – RSA 
# =============================================================

from Crypto.PublicKey import RSA
from Crypto.Cipher import PKCS1_OAEP
import base64
def generate_rsa(bits: int = 2048):
    key = RSA.generate(bits)
    return key.export_key(), key.publickey().export_key()
def rsa_encrypt(pub_pem: bytes, message: bytes) -> str:
    pub = RSA.import_key(pub_pem)
    cipher = PKCS1_OAEP.new(pub)
    ct = cipher.encrypt(message)
    return base64.b64encode(ct).decode()
def rsa_decrypt(priv_pem: bytes, b64_ct: str) -> bytes:
    priv = RSA.import_key(priv_pem)
    cipher = PKCS1_OAEP.new(priv)
    ct = base64.b64decode(b64_ct)
    return cipher.decrypt(ct)
if __name__ == "__main__":
    priv_pem, pub_pem = generate_rsa(2048)
    print("Generated keys (PEM lengths):", len(priv_pem), len(pub_pem))
    msg = input("\nEnter message to encrypt: ").encode()
    ct = rsa_encrypt(pub_pem, msg)
    print("\nCiphertext (base64):", ct)
    pt = rsa_decrypt(priv_pem, ct)
    print("Decrypted:", pt)

